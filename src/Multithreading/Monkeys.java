package Multithreading;


public class Monkeys {

    // Принцип: стараться обходиться без статических методов.
    public static void main(String[] args) {
        new Monkeys(); // создаём одну программу про обезьянок
    }

    //

    private int bananas = 1_000_000;
    private int total = 0;

    private Monkeys() {
        // Здесь основная логика программы

        // Обезьянка ест бананы
        /*
        int eaten = 0;
        while (bananas > 0) {
            bananas--; // bananas = bananas - 1
            eaten++; // eaten = eaten + 1
        }

        // %d - подставить число в десятичной системе счисления
        System.out.println(String.format("A monkey ate %,d bananas", eaten));
        */

        // Если нужно, чтобы программа одновременно выполняла несколько действий,
        // создаются потоки, по одному на каждое действие.
        // Нам нужно, чтобы две обезьянки ели бананы одновременно, поэтому создаём
        // два потока.

        Object monitor = new Object();

        // Runnable - это произвольный код, у него нет аргументов, он не возвращает результат.
        Runnable monkeyaction = () -> {
            int eaten = 0;
            while (bananas > 0) {
                // В скобках указывает любой объект. Он называется монитор
                // Если один поток взял монитор (т.е. вошёл в блок), то другие потоки
                // ждут, когда один монитор будет возвращён. В данном случае this - это объект Monkeys,
                // или можно создать специальный объект, который нужен только как монитор.
                synchronized (monitor) {
                    if (bananas > 0) {// повторная проверка, не съели ли уже банан
                        bananas--; // 1) узнать значение bananas 2) умменьшить 3) записать обратно
                        eaten++;
                    }
                }
            }
            synchronized (monitor) { // Используем глобальную переменную, необходима синхронизация.
                total += eaten;
            }
            // eaten - это переменная, у каждой обезьянки своя
            // bananas - это глобальная переменная
            System.out.println(String.format("A monkey ate %,d bananas, total bananas eaten %,d", eaten, total));
        };

        for (int i = 0; i < 10; i++)
            (new Thread(monkeyaction)).start();


        // Задание: обезьянок 10. И ещё одна глобальная переменная total. Каждая
        // обезьянка, после того как съела бананы, добавляет в total, сколько всего
        // она съела бананов, и печатает total на экран. Это нужно, чтобы проверить,
        // что все обезьянки в сумме съели ровно 1 000 000 бананов.

        // Задание: (можете изменять этот класс, а не тот, где 10 обезьянок)
        // Используйте AtomicInteger вместо int для bananas, он позволяет за одно действие
        // сделать проверку на 0 и вычесть единицу. (Monkeys10)
    }

    // Если не синхронизировать работу двух обезьянок, то в начале каждая решит, что
    // бананов 1_000_000, каждая уменьшит количество до 999_999 и запишет это число
    // в переменную (в поле) bananas. Т.е. бананов 999_999, но каждая обезьяна считает,
    // что она уже съела один банан.

    // Участки кода, которые нельзя выполнять одновременно нескольким потокам, надо
    // синхронизировать, т.е. явно указывать, что только один поток может выполнять
    // этот участок кода. Для этого есть ключевое слово synchronized.
    // Программирование с помощью synchronize очень сложное, особенно, если программа
    // большая и потоков много. Это самый низкоуровневый метод программирования.
}
